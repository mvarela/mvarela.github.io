<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fractals on </title>
    <link>https://mvarela.github.io/tags/fractals/</link>
    <description>Recent content in Fractals on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 26 Sep 2017 09:43:43 +0300</lastBuildDate>
    <atom:link href="/tags/fractals/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Fractals — Complexity from Simplicity (and a bit of Clojure)</title>
      <link>https://mvarela.github.io/post/fractals-complexity-from-simplicity/</link>
      <pubDate>Tue, 26 Sep 2017 09:43:43 +0300</pubDate>
      
      <guid>https://mvarela.github.io/post/fractals-complexity-from-simplicity/</guid>
      <description>&lt;!-- -*- org-export-babel-evaluate: nil -*- --&gt;

&lt;h1 id=&#34;enter-the-dragon&#34;&gt;Enter the Dragon&lt;/h1&gt;

&lt;p&gt;Fractals have always fascinated me. I remember seeing a render of a Mandelbrot
  set back in the early 90s (when color screens started being accessible back
  home), and being completely mesmerized by it. I remember being even more
  fascinated by seeing a code-golf version of such a renderer, implemented in
  some 300 bytes of C.&lt;/p&gt;

&lt;p&gt;Some days ago I came across the &#34;dragon curve&#34;, and decided to give it a go in
  Clojure, as a way to learn a bit more and have some fun. I implemented it as a 
  &lt;a href=&#34;https://en.wikipedia.org/wiki/L-system&#34; title=&#34;Lindenmayer system&#34; target=&#34;_blank&#34;&gt;Lindenmayer system&lt;/a&gt;, which reveals the simplicity behind it.&lt;/p&gt;

&lt;p&gt;L-systems are string re-writing systems, and have a set of constants,
  variables, rules, and a starting axiom. One starts with the axiom, and applies
  the rules to it. Each rule maps a variable to a new string that substitutes
  it. Constants are unaffected by the re-write, and remain in place.&lt;/p&gt;

&lt;p&gt;In the case of the dragon curve, it can be represented by the following
  L-system (described nicely in &lt;a href=&#34;https://en.wikipedia.org/wiki/L-system#Example_6:_Dragon_curve&#34; title=&#34;the wiki&#34; target=&#34;_blank&#34;&gt;the wiki&lt;/a&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
    variables : X Y
    constants : F + −
    start : FX
    rules : X → X+YF+
            Y → −FX−Y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to &#34;grow&#34; the dragon, we iterate by applying the rules to the axiom,
  and then to the result, and so on. For example, after two iterations on the
  axiom, we have:&lt;/p&gt;

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Iteration 1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Axiom&lt;/td&gt;
&lt;td&gt;FX&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Rule for X&lt;/td&gt;
&lt;td&gt;FX+YF+&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Iteration 2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Rule for X&lt;/td&gt;
&lt;td&gt;FX+YF++YF+&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Rule for Y&lt;/td&gt;
&lt;td&gt;FX+-FX-YF++-FX-YF+&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;These simple rules, and the simple starting point lead to an increasingly
complex string, where structure starts becoming visible. Of course, doing this
by hand is extremely tedious, so we can automate it with a bit of &lt;a href=&#34;https://clojure.org/&#34; title=&#34;Clojure&#34; target=&#34;_blank&#34;&gt;Clojure&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We can start by defining the axiom, and the re-writing rules.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;
  (ns dragon.core
    (:require [hiccup.core :as hiccup]))

  (def start [:F :X])

  (defn rewrite [i]
    (cond
      (= :X i) [:X :+ :Y :F :+]
      (= :Y i) [:- :F :X :- :Y]
      :true [i]))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now see what happens when we apply the rules to the axiom:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;
(map rewrite start)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;example&#34;&gt;
([:F] [:X :+ :Y :F :+])
&lt;/pre&gt;

&lt;p&gt;This is a bit noisy due to the brackets, but we can see it&#39;s the same result we
got by iterating by hand. Let&#39;s add a bit more functionality:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;
(defn dragon [segments iter]
  (if (zero? iter)
    segments
    (let [segs (vec (mapcat rewrite segments))]
      (recur segs (- iter 1)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can get rid of the extra brackets, and do some more iterations.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;
(map (partial dragon start) (range 4))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;example&#34;&gt;
([:F :X] 
 [:F :X :+ :Y :F :+] 
 [:F :X :+ :Y :F :+ :+ :- :F :X :- :Y :F :+] 
 [:F :X :+ :Y :F :+ :+ :- :F :X :- :Y :F :+ :+ :- 
  :F :X :+ :Y :F :+ :- :- :F :X :- :Y :F :+])
&lt;/pre&gt;

&lt;p&gt;As we can see in the (slightly reformatted) results, the string&#39;s size and
complexity keeps increasing.&lt;/p&gt;

&lt;p&gt;In order to visualize this fractal, we need some rules on how to interpret it.
This is also very simple, and in fact, it is pretty much the same as the
&lt;a href=&#34;https://en.wikipedia.org/wiki/Turtle_graphics&#34; title=&#34;turtle graphics&#34; target=&#34;_blank&#34;&gt;turtle graphics&lt;/a&gt; that were used in the &lt;a href=&#34;https://en.wikipedia.org/wiki/Logo_(programming_language)&#34; title=&#34;Logo language&#34; target=&#34;_blank&#34;&gt;Logo language&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this case, we will interpret the &lt;code&gt;F&lt;/code&gt; constant as &lt;code&gt;forward&lt;/code&gt; (that is, draw a
line in the direction the turtle is facing, and a fixed distance). The &lt;code&gt;+&lt;/code&gt; and
 &lt;code&gt;-&lt;/code&gt; constants will respectively mean &lt;code&gt;right 90&lt;/code&gt; and &lt;code&gt;left 90&lt;/code&gt;, that is, to
rotate the turtle by 90 degrees in a given direction. And that&#39;s all there is to
it (for now, anyway).&lt;/p&gt;

&lt;p&gt;We can again automate this quite easily:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;
(def pi:2 (/ Math/PI 2))
(def vec:size 3)

(defn points [segments theta acc x y]
  (if (empty? segments)
    acc
    (let [s  (first segments)
          xs (rest segments)]
      (cond
        (or (= s :X) (= s :Y)) (recur xs, theta, acc, x, y)
        (= s :+) (recur xs, (+ theta pi:2), acc, x, y)
        (= s :-) (recur xs, (- theta pi:2), acc, x, y)
        (= s :F) (let [xx (+ x (* vec:size (Math/cos theta)))
                       yy (+ y (* vec:size (Math/sin theta)))
                       new-acc (conj acc (vector xx yy))]
(recur xs, theta, new-acc, xx, yy))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We basically go over the generated string, and interpret it according to the
rules described above (ignore constants, draw when we find an &lt;code&gt;F&lt;/code&gt;, and turn in
the indicated direction when we find a &lt;code&gt;+&lt;/code&gt; or a &lt;code&gt;-&lt;/code&gt;. This gives us a list of
points which we can then use to build an SVG &lt;code&gt;polyline&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;
  (defn render-svg [plot-points]
    (let [width 1000
          height 1000
          xmlns &amp;quot;http://www.w3.org/2000/svg&amp;quot;
          style &amp;quot;stroke:#474674; fill:white;&amp;quot;
          points (apply str (map #(str (first %) &amp;quot;,&amp;quot; (second %) &amp;quot; &amp;quot;) plot-points))]
      (hiccup/html [:svg {:width width
                          :height height
                          :xmlns xmlns}
                    [:polyline {:points points
                                :style style}]])))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we are using the &lt;a href=&#34;https://github.com/weavejester/hiccup&#34; title=&#34;hiccup library&#34; target=&#34;_blank&#34;&gt;hiccup library&lt;/a&gt; for rendering HTML, and creating a
(potentially very large) &lt;code&gt;polyline&lt;/code&gt; element with all the points we defined
above.&lt;/p&gt;

&lt;p&gt;Now we can render our dragon and enjoy it in all its glory!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;
  (let [d    (dragon start 15)
        pts  (points d 0 [] 500 500)
        html (render-svg pts)]
    (spit &amp;quot;dragon15.html&amp;quot; html)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://mvarela.github.io/img/fractals/dragon15.png&#34; alt=&#34;/img/fractals/dragon15.png&#34; title=&#34;/img/fractals/dragon15.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you are reading this in a modern browser with proper SVG support, you can
also open the generated &lt;a href=&#34;http:/html/fractals/dragon15.html&#34; title=&#34;HTML output&#34; target=&#34;_blank&#34;&gt;HTML output&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;tidying-up&#34;&gt;Tidying Up&lt;/h1&gt;

&lt;p&gt;The code snippets above are fun for playing in the Clojure REPL, but they&#39;re
 don&#39;t generalize well, and can be improved upon significantly. In particular,
 they require some fiddling with the SVG rendering view-port and the starting
 point of the fractal drawing. I&#39;ve cleaned up the code a bit, and made it
 generic so it can support many other L-systems. It now lives on &lt;a href=&#34;https://github.com/mvarela/Fractal-Playground&#34; title=&#34;Github&#34; target=&#34;_blank&#34;&gt;Github&lt;/a&gt;, along
 with some other fractal code that we&#39;ll discuss in an upcoming post.&lt;/p&gt;

&lt;p&gt;The L-system code itself, if you are interested, lives &lt;a href=&#34;https://github.com/mvarela/Fractal-Playground/blob/master/src/fractals/l_system.clj&#34; title=&#34;here&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;more-fractal-goodness&#34;&gt;More Fractal Goodness&lt;/h1&gt;

&lt;p&gt;Lindenmayer systems can give rise to very many interesting fractals, and many
self-similar constructs can also be represented as L-systems. Below you can see
some of these.&lt;/p&gt;

&lt;h2 id=&#34;box-fractal&#34;&gt;Box Fractal&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;
axiom : F+F+F+F
rules : F → FF+F+F+F+FF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Five iterations of this system yield this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://mvarela.github.io/img/fractals/box5.png&#34; alt=&#34;/img/fractals/box5.png&#34; title=&#34;/img/fractals/box5.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http:/html/fractals/box-05.html&#34; title=&#34;HTML/SVG version&#34; target=&#34;_blank&#34;&gt;HTML/SVG version&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;crystal-fractal&#34;&gt;Crystal Fractal&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;
axiom : F+F+F+F
rules : F → FF+F++F+F
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like the Box above, this one also starts with a square (F+F+F+F).
Six iterations yield:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://mvarela.github.io/img/fractals/crystal6.png&#34; alt=&#34;/img/fractals/crystal6.png&#34; title=&#34;/img/fractals/crystal6.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http:/html/fractals/crystal-06.html&#34; title=&#34;HTML/SVG version&#34; target=&#34;_blank&#34;&gt;HTML/SVG version&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;hilbert-curve&#34;&gt;Hilbert Curve&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;
axiom : X
rules : X → +YF-XFX-FY+
        Y → -XF+YFY+FX-
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;https://en.wikipedia.org/wiki/Hilbert_curve&#34; title=&#34;Hilbert curve&#34; target=&#34;_blank&#34;&gt;Hilbert curve&lt;/a&gt; is a well-known space-filling fractal. It does get quite dense
rather quickly. After only 9 iterations, it looks like this.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://mvarela.github.io/img/fractals/hilbert9.png&#34; alt=&#34;/img/fractals/hilbert9.png&#34; title=&#34;/img/fractals/hilbert9.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http:/html/fractals/hilbert-09.html&#34; title=&#34;HTML/SVG version (LARGE FILE!)&#34; target=&#34;_blank&#34;&gt;HTML/SVG version (LARGE FILE!)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Zooming in a bit, we can better discern the structure:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://mvarela.github.io/img/fractals/hilbert9zoom.png&#34; alt=&#34;/img/fractals/hilbert9zoom.png&#34; title=&#34;/img/fractals/hilbert9zoom.png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;koch-curve&#34;&gt;Koch Curve&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;
axiom : F+F+F+F
rules : F → FF+F+F+F+FF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This one also becomes complex very quickly. At four iterations, it looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://mvarela.github.io/img/fractals/koch4.png&#34; alt=&#34;/img/fractals/koch4.png&#34; title=&#34;/img/fractals/koch4.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http:/html/fractals/koch-curve-04.html&#34; title=&#34;HTML/SVG version&#34; target=&#34;_blank&#34;&gt;HTML/SVG version&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;koch-snowflake&#34;&gt;Koch Snowflake&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;
axiom : F--F--F
rules : F → F+F--F+F
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is another well-known fractal.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://mvarela.github.io/img/fractals/snowflake9.png&#34; alt=&#34;/img/fractals/snowflake9.png&#34; title=&#34;/img/fractals/snowflake9.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http:/html/fractals/koch-snowflake-09.html&#34; title=&#34;HTML/SVG version&#34; target=&#34;_blank&#34;&gt;HTML/SVG version&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;rings&#34;&gt;Rings&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;
axiom : F+F+F+F
rules : F → FF+F+F+F+F+F-F
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This one is quite eye-catching. After six itertations, we get:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://mvarela.github.io/img/fractals/rings6.png&#34; alt=&#34;/img/fractals/rings6.png&#34; title=&#34;/img/fractals/rings6.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http:/html/fractals/rings-06.html&#34; title=&#34;HTML/SVG version&#34; target=&#34;_blank&#34;&gt;HTML/SVG version&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;sierpiński-triangle&#34;&gt;Sierpiński Triangle&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;
axiom : F-G-G
rules : F → F-G+F+G-F
        G → GG
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Sierpiński triangle is another very well known fractal. Unlike the ones seen
above, it has two &lt;code&gt;forward&lt;/code&gt; variables, &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt;. After 8 iterations, it
results in this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://mvarela.github.io/img/fractals/sierpinski8.png&#34; alt=&#34;/img/fractals/sierpinski8.png&#34; title=&#34;/img/fractals/sierpinski8.png&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;more-to-come&#34;&gt;More to Come!&lt;/h1&gt;

&lt;p&gt;In this post we have covered the basics of L-system based fractals. There is a
bit more to them, as more &#34;commands&#34; can be embedded in the fractal string, such
as &lt;code&gt;moving&lt;/code&gt; the turtle without drawing, and &lt;code&gt;pushing&lt;/code&gt; and &lt;code&gt;popping&lt;/code&gt; state onto a
stack, to allow for the generation of more complex patterns. The L-system
processing code on Github has some partial support for those, but the renderer
doesn&#39;t, so some further work is needed there.&lt;/p&gt;

&lt;p&gt;A second part to this incursion into fractals is upcoming. There we&#39;ll look into
two different types of fractals. The first type is based on affine
transformations and stochastic processes, and the second one is the famous
&lt;a href=&#34;https://en.wikipedia.org/wiki/Mandelbrot_set&#34; title=&#34;Mandelbrot set&#34; target=&#34;_blank&#34;&gt;Mandelbrot set&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
